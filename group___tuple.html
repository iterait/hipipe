<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HiPipe: Tuple and variadic template utilites.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HiPipe
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">C++17 data pipeline with Python bindings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tuple and variadic template utilites.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhipipe_1_1utility_1_1variadic__find.html">hipipe::utility::variadic_find&lt; T1, T2, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of a type in a variadic template list.  <a href="structhipipe_1_1utility_1_1variadic__find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhipipe_1_1utility_1_1maybe__tuple__impl.html">hipipe::utility::maybe_tuple_impl&lt; N, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap variadic template pack in a tuple if there is more than one type.  <a href="structhipipe_1_1utility_1_1maybe__tuple__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhipipe_1_1utility_1_1tuple__contains.html">hipipe::utility::tuple_contains&lt; T, Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tuple contains a given type.  <a href="structhipipe_1_1utility_1_1tuple__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga883a430dccb7ffcc9e21454cb3892ff7"><td class="memTemplParams" colspan="2">template&lt;std::size_t Offset, std::size_t N&gt; </td></tr>
<tr class="memitem:ga883a430dccb7ffcc9e21454cb3892ff7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga883a430dccb7ffcc9e21454cb3892ff7">hipipe::utility::make_offset_index_sequence</a> = decltype(plus&lt; Offset &gt;(std::make_index_sequence&lt; N &gt;{}))</td></tr>
<tr class="memdesc:ga883a430dccb7ffcc9e21454cb3892ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make std::index_sequence with the given offset.  <a href="group___tuple.html#ga883a430dccb7ffcc9e21454cb3892ff7">More...</a><br /></td></tr>
<tr class="separator:ga883a430dccb7ffcc9e21454cb3892ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0ffa858796b6177a5de363a7168e9e36"><td class="memTemplParams" colspan="2">template&lt;std::size_t Value, std::size_t... Is&gt; </td></tr>
<tr class="memitem:ga0ffa858796b6177a5de363a7168e9e36"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::index_sequence&lt;(Value+Is)... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga0ffa858796b6177a5de363a7168e9e36">hipipe::utility::plus</a> (std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ga0ffa858796b6177a5de363a7168e9e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a number to all values in std::index_sequence.  <a href="group___tuple.html#ga0ffa858796b6177a5de363a7168e9e36">More...</a><br /></td></tr>
<tr class="separator:ga0ffa858796b6177a5de363a7168e9e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9961c2170337d529968ce1041ab4c8f"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:gaa9961c2170337d529968ce1041ab4c8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gaa9961c2170337d529968ce1041ab4c8f">hipipe::utility::tuple_for_each</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:gaa9961c2170337d529968ce1041ab4c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on each element of a tuple.  <a href="group___tuple.html#gaa9961c2170337d529968ce1041ab4c8f">More...</a><br /></td></tr>
<tr class="separator:gaa9961c2170337d529968ce1041ab4c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c87ffe36318ca892cd9f7780ff84391"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:ga7c87ffe36318ca892cd9f7780ff84391"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga7c87ffe36318ca892cd9f7780ff84391">hipipe::utility::tuple_transform</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga7c87ffe36318ca892cd9f7780ff84391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform each element of a tuple.  <a href="group___tuple.html#ga7c87ffe36318ca892cd9f7780ff84391">More...</a><br /></td></tr>
<tr class="separator:ga7c87ffe36318ca892cd9f7780ff84391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fc86f8a8c646dcc2c00cc8e0776f05"><td class="memTemplParams" colspan="2"><a id="ga24fc86f8a8c646dcc2c00cc8e0776f05"></a>
template&lt;typename Tuple , size_t... Is&gt; </td></tr>
<tr class="memitem:ga24fc86f8a8c646dcc2c00cc8e0776f05"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga24fc86f8a8c646dcc2c00cc8e0776f05">hipipe::utility::tuple_print</a> (std::ostream &amp;out, const Tuple &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ga24fc86f8a8c646dcc2c00cc8e0776f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple pretty printing to std::ostream. <br /></td></tr>
<tr class="separator:ga24fc86f8a8c646dcc2c00cc8e0776f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a677e1bc915bcaed98fc735d7c10a2"><td class="memTemplParams" colspan="2"><a id="gab0a677e1bc915bcaed98fc735d7c10a2"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab0a677e1bc915bcaed98fc735d7c10a2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gab0a677e1bc915bcaed98fc735d7c10a2">hipipe::utility::operator&lt;&lt;</a> (std::ostream &amp;out, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:gab0a677e1bc915bcaed98fc735d7c10a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple pretty printing to std::ostream. <br /></td></tr>
<tr class="separator:gab0a677e1bc915bcaed98fc735d7c10a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b8e032805197091c7ee80f9b17e770"><td class="memTemplParams" colspan="2">template&lt;typename Rng , CONCEPT_REQUIRES_(ranges::Range&lt; Rng &gt;() &amp;&amp;!ranges::View&lt; Rng &gt;()) &gt; </td></tr>
<tr class="memitem:gab5b8e032805197091c7ee80f9b17e770"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gab5b8e032805197091c7ee80f9b17e770">hipipe::utility::unzip</a> (Rng range_of_tuples)</td></tr>
<tr class="memdesc:gab5b8e032805197091c7ee80f9b17e770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzips a range of tuples to a tuple of ranges.  <a href="group___tuple.html#gab5b8e032805197091c7ee80f9b17e770">More...</a><br /></td></tr>
<tr class="separator:gab5b8e032805197091c7ee80f9b17e770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5ad83cdaa325bc48a84582231aa0c7"><td class="memTemplParams" colspan="2">template&lt;bool Enable, typename RangeT &gt; </td></tr>
<tr class="memitem:ga9e5ad83cdaa325bc48a84582231aa0c7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga9e5ad83cdaa325bc48a84582231aa0c7">hipipe::utility::unzip_if</a> (RangeT &amp;&amp;range)</td></tr>
<tr class="memdesc:ga9e5ad83cdaa325bc48a84582231aa0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzips a range of tuples to a tuple of ranges if a constexpr condition holds.  <a href="group___tuple.html#ga9e5ad83cdaa325bc48a84582231aa0c7">More...</a><br /></td></tr>
<tr class="separator:ga9e5ad83cdaa325bc48a84582231aa0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3573c0a654808abfd1f23931381e46"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:gaad3573c0a654808abfd1f23931381e46"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gaad3573c0a654808abfd1f23931381e46">hipipe::utility::maybe_untuple</a> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:gaad3573c0a654808abfd1f23931381e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a value from a tuple if the tuple contains only a single value.  <a href="group___tuple.html#gaad3573c0a654808abfd1f23931381e46">More...</a><br /></td></tr>
<tr class="separator:gaad3573c0a654808abfd1f23931381e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25612b3411904b8473ac80d4c71903b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Fun &gt; </td></tr>
<tr class="memitem:gaf25612b3411904b8473ac80d4c71903b"><td class="memTemplItemLeft" align="right" valign="top">constexpr Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gaf25612b3411904b8473ac80d4c71903b">hipipe::utility::times_with_index</a> (Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:gaf25612b3411904b8473ac80d4c71903b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat a function N times in compile time.  <a href="group___tuple.html#gaf25612b3411904b8473ac80d4c71903b">More...</a><br /></td></tr>
<tr class="separator:gaf25612b3411904b8473ac80d4c71903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523ac02152dbf96252faa5e85dec8cba"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:ga523ac02152dbf96252faa5e85dec8cba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga523ac02152dbf96252faa5e85dec8cba">hipipe::utility::tuple_for_each_with_index</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga523ac02152dbf96252faa5e85dec8cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group___tuple.html#gaa9961c2170337d529968ce1041ab4c8f" title="Apply a function on each element of a tuple. ">tuple_for_each()</a>, but with index available.  <a href="group___tuple.html#ga523ac02152dbf96252faa5e85dec8cba">More...</a><br /></td></tr>
<tr class="separator:ga523ac02152dbf96252faa5e85dec8cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd73f88d60339287bf6f0df3357937d"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:ga2dd73f88d60339287bf6f0df3357937d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga2dd73f88d60339287bf6f0df3357937d">hipipe::utility::tuple_transform_with_index</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga2dd73f88d60339287bf6f0df3357937d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group___tuple.html#ga7c87ffe36318ca892cd9f7780ff84391" title="Transform each element of a tuple. ">tuple_transform()</a>, but with index available.  <a href="group___tuple.html#ga2dd73f88d60339287bf6f0df3357937d">More...</a><br /></td></tr>
<tr class="separator:ga2dd73f88d60339287bf6f0df3357937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga883a430dccb7ffcc9e21454cb3892ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883a430dccb7ffcc9e21454cb3892ff7">&#9670;&nbsp;</a></span>make_offset_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Offset, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___tuple.html#ga883a430dccb7ffcc9e21454cb3892ff7">hipipe::utility::make_offset_index_sequence</a> = typedef decltype(plus&lt;Offset&gt;(std::make_index_sequence&lt;N&gt;{}))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make std::index_sequence with the given offset. </p>
<p>Example: </p><div class="fragment"><div class="line">std::is_same&lt;decltype(make_offset_index_sequence&lt;3, 4&gt;()),</div><div class="line">                      std::index_sequence&lt;3, 4, 5, 6&gt;&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00091">91</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaad3573c0a654808abfd1f23931381e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad3573c0a654808abfd1f23931381e46">&#9670;&nbsp;</a></span>maybe_untuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) hipipe::utility::maybe_untuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a value from a tuple if the tuple contains only a single value. </p>
<p>If the tuple contains zero or more than one element, this is an identity.</p>
<p>Example: </p><div class="fragment"><div class="line">std::tuple&lt;int, double&gt; t1{1, 3.};</div><div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="group___tuple.html#gaad3573c0a654808abfd1f23931381e46">maybe_untuple</a>(t1);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t2), std::tuple&lt;int, double&gt;&gt;);</div><div class="line"></div><div class="line">std::tuple&lt;int&gt; t3{1};</div><div class="line"><span class="keyword">auto</span> t4 = <a class="code" href="group___tuple.html#gaad3573c0a654808abfd1f23931381e46">maybe_untuple</a>(t3);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t4), <span class="keywordtype">int</span>&gt;);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> i = 1;</div><div class="line">std::tuple&lt;int&amp;&gt; t5{i};</div><div class="line"><span class="keyword">auto</span>&amp; t6 = <a class="code" href="group___tuple.html#gaad3573c0a654808abfd1f23931381e46">maybe_untuple</a>(t5);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t6), <span class="keywordtype">int</span>&amp;&gt;);</div><div class="line">t6 = 2;</div><div class="line">BOOST_TEST(i == 2);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00371">371</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga0ffa858796b6177a5de363a7168e9e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ffa858796b6177a5de363a7168e9e36">&#9670;&nbsp;</a></span>plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Value, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::index_sequence&lt;(Value + Is)...&gt; hipipe::utility::plus </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a number to all values in std::index_sequence. </p>
<p>Example: </p><div class="fragment"><div class="line">std::is_same&lt;decltype(plus&lt;2&gt;(std::index_sequence&lt;1, 3, 4&gt;{})),</div><div class="line">                              std::index_sequence&lt;3, 5, 6&gt;&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00077">77</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gaf25612b3411904b8473ac80d4c71903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf25612b3411904b8473ac80d4c71903b">&#9670;&nbsp;</a></span>times_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Fun hipipe::utility::times_with_index </td>
          <td>(</td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat a function N times in compile time. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 0.25, <span class="charliteral">&#39;a&#39;</span>);</div><div class="line"></div><div class="line">times_with_index&lt;3&gt;([&amp;tpl](<span class="keyword">auto</span> index) {</div><div class="line">    ++std::get&lt;index&gt;(tpl);</div><div class="line">});</div><div class="line">assert(tpl == std::make_tuple(2, 1.25, <span class="charliteral">&#39;b&#39;</span>));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00403">403</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gaa9961c2170337d529968ce1041ab4c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9961c2170337d529968ce1041ab4c8f">&#9670;&nbsp;</a></span>tuple_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::utility::tuple_for_each </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function on each element of a tuple. </p>
<p>The order of application is from the first to the last element.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(5, 2.);</div><div class="line"><a class="code" href="group___tuple.html#gaa9961c2170337d529968ce1041ab4c8f">tuple_for_each</a>(tpl, [](<span class="keyword">auto</span>&amp; val) { std::cout &lt;&lt; val &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; });</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The function after application. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00119">119</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga523ac02152dbf96252faa5e85dec8cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523ac02152dbf96252faa5e85dec8cba">&#9670;&nbsp;</a></span>tuple_for_each_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::utility::tuple_for_each_with_index </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group___tuple.html#gaa9961c2170337d529968ce1041ab4c8f" title="Apply a function on each element of a tuple. ">tuple_for_each()</a>, but with index available. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 2.);</div><div class="line"></div><div class="line"><a class="code" href="group___tuple.html#ga523ac02152dbf96252faa5e85dec8cba">tuple_for_each_with_index</a>(tpl, [](<span class="keyword">auto</span>&amp; val, <span class="keyword">auto</span> index) {</div><div class="line">    val += index;</div><div class="line">});</div><div class="line"></div><div class="line">assert(tpl == std::make_tuple(1, 3.));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00422">422</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga7c87ffe36318ca892cd9f7780ff84391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c87ffe36318ca892cd9f7780ff84391">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::utility::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform each element of a tuple. </p>
<p>The order of application is unspecified.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(0, 10L, 5.);</div><div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="group___tuple.html#ga7c87ffe36318ca892cd9f7780ff84391">tuple_transform</a>(t1, [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v) { <span class="keywordflow">return</span> v + 1; });</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;int, long, double&gt;, decltype(t2)&gt;{});</div><div class="line">assert(t2 == std::make_tuple(0 + 1, 10L + 1, 5. + 1));</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The transformed tuple. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00154">154</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga2dd73f88d60339287bf6f0df3357937d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd73f88d60339287bf6f0df3357937d">&#9670;&nbsp;</a></span>tuple_transform_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::utility::tuple_transform_with_index </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group___tuple.html#ga7c87ffe36318ca892cd9f7780ff84391" title="Transform each element of a tuple. ">tuple_transform()</a>, but with index available. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 0.25, <span class="charliteral">&#39;a&#39;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tpl2 = <a class="code" href="group___tuple.html#ga2dd73f88d60339287bf6f0df3357937d">tuple_transform_with_index</a>(tpl, [](<span class="keyword">auto</span>&amp;&amp; elem, <span class="keyword">auto</span> index) {</div><div class="line">    <span class="keywordflow">return</span> elem + index;</div><div class="line">});</div><div class="line"></div><div class="line">assert(tpl2 == std::make_tuple(1, 1.25, <span class="charliteral">&#39;c&#39;</span>));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00458">458</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gab5b8e032805197091c7ee80f9b17e770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b8e032805197091c7ee80f9b17e770">&#9670;&nbsp;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , CONCEPT_REQUIRES_(ranges::Range&lt; Rng &gt;() &amp;&amp;!ranges::View&lt; Rng &gt;()) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::utility::unzip </td>
          <td>(</td>
          <td class="paramtype">Rng&#160;</td>
          <td class="paramname"><em>range_of_tuples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unzips a range of tuples to a tuple of ranges. </p>
<p>Specialization of unzip function for views.</p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data{};</div><div class="line">data.emplace_back(1, 5.);</div><div class="line">data.emplace_back(2, 6.);</div><div class="line">data.emplace_back(3, 7.);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; va;</div><div class="line">std::vector&lt;double&gt; vb;</div><div class="line">std::tie(va, vb) = <a class="code" href="group___tuple.html#gab5b8e032805197091c7ee80f9b17e770">unzip</a>(data);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00257">257</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga9e5ad83cdaa325bc48a84582231aa0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e5ad83cdaa325bc48a84582231aa0c7">&#9670;&nbsp;</a></span>unzip_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Enable, typename RangeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) hipipe::utility::unzip_if </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unzips a range of tuples to a tuple of ranges if a constexpr condition holds. </p>
<p>This method is enabled or disabled by its first template parameter. If disabled, it returns identity. If enabled, it returns the same thing as <a class="el" href="group___tuple.html#gab5b8e032805197091c7ee80f9b17e770" title="Unzips a range of tuples to a tuple of ranges. ">unzip()</a> would return.</p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data{};</div><div class="line">data.emplace_back(1, 5.);</div><div class="line">data.emplace_back(2, 6.);</div><div class="line">data.emplace_back(3, 7.);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; va;</div><div class="line">std::vector&lt;double&gt; vb;</div><div class="line">std::tie(va, vb) = unzip_if&lt;true&gt;(data);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vc = unzip_if&lt;false&gt;(va);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00317">317</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
