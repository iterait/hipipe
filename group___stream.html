<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HiPipe: Stream modifiers and data types.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HiPipe
   &#160;<span id="projectnumber">0.5.1</span>
   </div>
   <div id="projectbrief">C++17 data pipeline with Python bindings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Stream modifiers and data types.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for hipipe columns.  <a href="classhipipe_1_1stream_1_1column__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacf90e1f464c32aa14857b51f72e685ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(col_name,  col_type)</td></tr>
<tr class="memdesc:gacf90e1f464c32aa14857b51f72e685ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for fast column definition.  <a href="#gacf90e1f464c32aa14857b51f72e685ee">More...</a><br /></td></tr>
<tr class="separator:gacf90e1f464c32aa14857b51f72e685ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga173fbf092fa3f20cb14a7bc163658aaa"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ByColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:ga173fbf092fa3f20cb14a7bc163658aaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga173fbf092fa3f20cb14a7bc163658aaa">hipipe::stream::filter</a> (from_t&lt; FromColumns... &gt; f, by_t&lt; ByColumns... &gt; b, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga173fbf092fa3f20cb14a7bc163658aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter stream data.  <a href="group___stream.html#ga173fbf092fa3f20cb14a7bc163658aaa">More...</a><br /></td></tr>
<tr class="separator:ga173fbf092fa3f20cb14a7bc163658aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b52de22d52808741d8903adb09ef842"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:ga6b52de22d52808741d8903adb09ef842"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga6b52de22d52808741d8903adb09ef842">hipipe::stream::for_each</a> (from_t&lt; FromColumns... &gt; f, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga6b52de22d52808741d8903adb09ef842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a subset of stream columns.  <a href="group___stream.html#ga6b52de22d52808741d8903adb09ef842">More...</a><br /></td></tr>
<tr class="separator:ga6b52de22d52808741d8903adb09ef842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90580a65a27b29ba3f3f6c18887178f5"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename ToColumn , typename Gen , int Dim = utility::ndims&lt;typename ToColumn::batch_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Gen()&gt;&gt;::value&gt; </td></tr>
<tr class="memitem:ga90580a65a27b29ba3f3f6c18887178f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga90580a65a27b29ba3f3f6c18887178f5">hipipe::stream::generate</a> (from_t&lt; FromColumn &gt; size_from, to_t&lt; ToColumn &gt; fill_to, Gen gen, long gendims=std::numeric_limits&lt; long &gt;::max(), dim_t&lt; Dim &gt; d=dim_t&lt; Dim &gt;{})</td></tr>
<tr class="memdesc:ga90580a65a27b29ba3f3f6c18887178f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the selected column using a generator (i.e., a nullary function).  <a href="group___stream.html#ga90580a65a27b29ba3f3f6c18887178f5">More...</a><br /></td></tr>
<tr class="separator:ga90580a65a27b29ba3f3f6c18887178f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c4a9c96aa1f276e23025b662443b02"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename MaskColumn , typename ValT  = typename utility::ndim_type_t&lt;      typename FromColumn::batch_type,       utility::ndims&lt;typename MaskColumn::batch_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga81c4a9c96aa1f276e23025b662443b02"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga81c4a9c96aa1f276e23025b662443b02">hipipe::stream::pad</a> (from_t&lt; FromColumn &gt; f, mask_t&lt; MaskColumn &gt; m, ValT value=ValT{})</td></tr>
<tr class="memdesc:ga81c4a9c96aa1f276e23025b662443b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the selected column to a rectangular size.  <a href="group___stream.html#ga81c4a9c96aa1f276e23025b662443b02">More...</a><br /></td></tr>
<tr class="separator:ga81c4a9c96aa1f276e23025b662443b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d752475cd1ba336c7a3650f7cdf12b"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename ToColumn , typename Prng  = std::mt19937, typename Dist  = std::uniform_real_distribution&lt;double&gt;, int Dim = utility::ndims&lt;typename ToColumn::batch_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Dist(Prng&amp;)&gt;&gt;::value&gt; </td></tr>
<tr class="memitem:ga43d752475cd1ba336c7a3650f7cdf12b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga43d752475cd1ba336c7a3650f7cdf12b">hipipe::stream::random_fill</a> (from_t&lt; FromColumn &gt; size_from, to_t&lt; ToColumn &gt; fill_to, long rnddims=std::numeric_limits&lt; long &gt;::max(), Dist dist=Dist{0, 1}, Prng &amp;prng=hipipe::utility::random_generator, dim_t&lt; Dim &gt; d=dim_t&lt; Dim &gt;{})</td></tr>
<tr class="memdesc:ga43d752475cd1ba336c7a3650f7cdf12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the selected column of a stream with random values.  <a href="group___stream.html#ga43d752475cd1ba336c7a3650f7cdf12b">More...</a><br /></td></tr>
<tr class="separator:ga43d752475cd1ba336c7a3650f7cdf12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86eb72187b1b478933826aed7c5b8f52"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:ga86eb72187b1b478933826aed7c5b8f52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga86eb72187b1b478933826aed7c5b8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a subset of hipipe columns to a different subset of hipipe columns.  <a href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">More...</a><br /></td></tr>
<tr class="separator:ga86eb72187b1b478933826aed7c5b8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab8f89c1686645bed7e61fb5f46f104"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename CondColumn , typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:gaeab8f89c1686645bed7e61fb5f46f104"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gaeab8f89c1686645bed7e61fb5f46f104">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, cond_t&lt; CondColumn &gt; c, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:gaeab8f89c1686645bed7e61fb5f46f104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional transform of a subset of hipipe columns.  <a href="group___stream.html#gaeab8f89c1686645bed7e61fb5f46f104">More...</a><br /></td></tr>
<tr class="separator:gaeab8f89c1686645bed7e61fb5f46f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5933ec8bbd6d6d3c9f41cbd16690c774"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename Fun , typename Prng  = std::mt19937, int Dim = 1&gt; </td></tr>
<tr class="memitem:ga5933ec8bbd6d6d3c9f41cbd16690c774"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga5933ec8bbd6d6d3c9f41cbd16690c774">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, double prob, Fun fun, Prng &amp;prng=utility::random_generator, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga5933ec8bbd6d6d3c9f41cbd16690c774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probabilistic transform of a subset of hipipe columns.  <a href="group___stream.html#ga5933ec8bbd6d6d3c9f41cbd16690c774">More...</a><br /></td></tr>
<tr class="separator:ga5933ec8bbd6d6d3c9f41cbd16690c774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953e08640cd203ba8f39bb727e3a1acf"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename... FromColumns, int Dim = 1&gt; </td></tr>
<tr class="memitem:ga953e08640cd203ba8f39bb727e3a1acf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga953e08640cd203ba8f39bb727e3a1acf">hipipe::stream::unpack</a> (Rng &amp;&amp;rng, from_t&lt; FromColumns... &gt; f, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga953e08640cd203ba8f39bb727e3a1acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a stream into a tuple of ranges.  <a href="group___stream.html#ga953e08640cd203ba8f39bb727e3a1acf">More...</a><br /></td></tr>
<tr class="separator:ga953e08640cd203ba8f39bb727e3a1acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga31e083506fa747e23bee7f76b9a88814"><td class="memItemLeft" align="right" valign="top">constexpr ranges::view::view&lt; batch_fn &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#ga31e083506fa747e23bee7f76b9a88814">hipipe::stream::batch</a> {}</td></tr>
<tr class="memdesc:ga31e083506fa747e23bee7f76b9a88814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate the stream and yield batches of a different size.  <a href="group___stream.html#ga31e083506fa747e23bee7f76b9a88814">More...</a><br /></td></tr>
<tr class="separator:ga31e083506fa747e23bee7f76b9a88814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf6c7ccdd801356e7f6ea5fabb76db8"><td class="memItemLeft" align="right" valign="top">constexpr ranges::view::view&lt; buffer_fn &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#ga3cf6c7ccdd801356e7f6ea5fabb76db8">hipipe::stream::buffer</a> {}</td></tr>
<tr class="memdesc:ga3cf6c7ccdd801356e7f6ea5fabb76db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously buffers the given range.  <a href="group___stream.html#ga3cf6c7ccdd801356e7f6ea5fabb76db8">More...</a><br /></td></tr>
<tr class="separator:ga3cf6c7ccdd801356e7f6ea5fabb76db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56891f9101f14ac09d0d247f6b79c24"><td class="memTemplParams" colspan="2">template&lt;typename... Columns&gt; </td></tr>
<tr class="memitem:gae56891f9101f14ac09d0d247f6b79c24"><td class="memTemplItemLeft" align="right" valign="top">constexpr ranges::view::view&lt; detail::create_fn&lt; Columns... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gae56891f9101f14ac09d0d247f6b79c24">hipipe::stream::create</a> {}</td></tr>
<tr class="memdesc:gae56891f9101f14ac09d0d247f6b79c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a range to a stream (i.e., to a range of tuples of columns).  <a href="group___stream.html#gae56891f9101f14ac09d0d247f6b79c24">More...</a><br /></td></tr>
<tr class="separator:gae56891f9101f14ac09d0d247f6b79c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5649697e86eea6020c2035777f98c1be"><td class="memTemplParams" colspan="2">template&lt;typename... Columns&gt; </td></tr>
<tr class="memitem:ga5649697e86eea6020c2035777f98c1be"><td class="memTemplItemLeft" align="right" valign="top">constexpr ranges::view::view&lt; detail::drop_fn&lt; Columns... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga5649697e86eea6020c2035777f98c1be">hipipe::stream::drop</a> {}</td></tr>
<tr class="memdesc:ga5649697e86eea6020c2035777f98c1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops columns from a stream.  <a href="group___stream.html#ga5649697e86eea6020c2035777f98c1be">More...</a><br /></td></tr>
<tr class="separator:ga5649697e86eea6020c2035777f98c1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacf90e1f464c32aa14857b51f72e685ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf90e1f464c32aa14857b51f72e685ee">&#9670;&nbsp;</a></span>HIPIPE_DEFINE_COLUMN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HIPIPE_DEFINE_COLUMN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>col_name : <a class="code" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base</a>&lt;col_type&gt; {       \</div><div class="line">    using <a class="code" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base&lt;col_type&gt;::column_base</a>;   \</div><div class="line">    static constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* name() { <span class="keywordflow">return</span> #col_name; }   \</div><div class="line">};</div><div class="ttc" id="classhipipe_1_1stream_1_1column__base_html"><div class="ttname"><a href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base</a></div><div class="ttdoc">Base class for hipipe columns. </div><div class="ttdef"><b>Definition:</b> <a href="column_8hpp_source.html#l00025">column.hpp:25</a></div></div>
</div><!-- fragment -->
<p>Macro for fast column definition. </p>
<p>Under the hood, it creates a new type derived from column_base. </p>

<p class="definition">Definition at line <a class="el" href="column_8hpp_source.html#l00091">91</a> of file <a class="el" href="column_8hpp_source.html">column.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga173fbf092fa3f20cb14a7bc163658aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173fbf092fa3f20cb14a7bc163658aaa">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ByColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::filter </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">by_t&lt; ByColumns... &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter stream data. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id, value&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#ga173fbf092fa3f20cb14a7bc163658aaa">filter</a>(from&lt;id, value&gt;, by&lt;value&gt;, [](<span class="keywordtype">double</span> value) { <span class="keywordflow">return</span> value &gt; 3.; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be filtered. </td></tr>
    <tr><td class="paramname">b</td><td>The columns to be passed to the filtering function. Those have to be a subset of f. </td></tr>
    <tr><td class="paramname">fun</td><td>The filtering function returning a boolean. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which the function is applied. Choose 0 to filter whole batches (in such a case, the f parameter is ignored). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="filter_8hpp_source.html#l00128">128</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a id="ga6b52de22d52808741d8903adb09ef842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b52de22d52808741d8903adb09ef842">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::for_each </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to a subset of stream columns. </p>
<p>The given function is applied to a subset of columns given by FromColumns. The transformed range is the same as the input range, no elements are actually changed. The function is applied lazily, i.e., only when the range is iterated.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(Int, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(Double, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;Int, Double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | <a class="code" href="group___stream.html#ga6b52de22d52808741d8903adb09ef842">for_each</a>(from&lt;Int, Double&gt;, [](<span class="keywordtype">int</span>&amp; v, <span class="keywordtype">double</span>&amp; d) { std::cout &lt;&lt; c + d; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be exctracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which the function is applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="for__each_8hpp_source.html#l00060">60</a> of file <a class="el" href="for__each_8hpp_source.html">for_each.hpp</a>.</p>

</div>
</div>
<a id="ga90580a65a27b29ba3f3f6c18887178f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90580a65a27b29ba3f3f6c18887178f5">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename ToColumn , typename Gen , int Dim = utility::ndims&lt;typename ToColumn::batch_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Gen()&gt;&gt;::value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::generate </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>size_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumn &gt;&#160;</td>
          <td class="paramname"><em>fill_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>gendims</em> = <code>std::numeric_limits&lt;long&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;Dim&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the selected column using a generator (i.e., a nullary function). </p>
<p>This function uses <a class="el" href="group___vector.html#gaac4d8a7d79ece0155f2667cc5c31662c">utility::generate()</a>. Furthermore, the column to be filled is first resized so that it has the same size as the selected source column.</p>
<p>Tip: If there is no column the size could be taken from, than just resize the target column manually and use it as both <code>from</code> column and <code>to</code> column.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 2};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id&gt;()</div><div class="line">  <span class="comment">// assign each id a value from an increasing sequence</span></div><div class="line">  | <a class="code" href="group___vector.html#gaac4d8a7d79ece0155f2667cc5c31662c">generate</a>(from&lt;id&gt;, to&lt;value&gt;, [i = 0]() mutable { <span class="keywordflow">return</span> i++; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_from</td><td>The column whose size will be used to initialize the generated column. </td></tr>
    <tr><td class="paramname">fill_to</td><td>The column to be filled using the generator. </td></tr>
    <tr><td class="paramname">gen</td><td>The generator to be used. </td></tr>
    <tr><td class="paramname">gendims</td><td>The number of generated dimensions. See <a class="el" href="group___vector.html#gaac4d8a7d79ece0155f2667cc5c31662c">utility::generate()</a>. </td></tr>
    <tr><td class="paramname">d</td><td>This is the dimension in which will the generator be applied. E.g., if set to 1, the generator result is considered to be a single example. The default is ndims&lt;ToColumn::batch_type&gt; - ndims&lt;gen()&gt;. This value has to be positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate_8hpp_source.html#l00078">78</a> of file <a class="el" href="generate_8hpp_source.html">generate.hpp</a>.</p>

</div>
</div>
<a id="ga81c4a9c96aa1f276e23025b662443b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c4a9c96aa1f276e23025b662443b02">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename MaskColumn , typename ValT  = typename utility::ndim_type_t&lt;      typename FromColumn::batch_type,       utility::ndims&lt;typename MaskColumn::batch_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::pad </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_t&lt; MaskColumn &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValT&#160;</td>
          <td class="paramname"><em>value</em> = <code>ValT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the selected column to a rectangular size. </p>
<p>Each batch is padded separately.</p>
<p>The mask of the padded values is created along with the padding. The mask evaluates to <code>true</code> on the positions with the original elements and to <code>false</code> on the positions of the padded elements. The mask column should be a multidimensional vector of type bool/char/int/... The dimensionality of the mask column is used to deduce how many dimensions should be padded in the source column.</p>
<p>This transformer internally uses <a class="el" href="group___vector.html#gacf969a6b1e95eec834e4a1028d2ea9cd">utility::ndim_pad()</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(sequences, std::vector&lt;int&gt;)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(sequence_masks, std::vector&lt;bool&gt;)</div><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; data = {{1, 2}, {3, 4, 5}, {}, {6, 7}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;sequences&gt;(2)</div><div class="line">  | <a class="code" href="group___stream.html#ga81c4a9c96aa1f276e23025b662443b02">pad</a>(from&lt;sequences&gt;, mask&lt;sequence_masks&gt;, -1);</div><div class="line"><span class="comment">// sequences_batch_1 == {{1, 2, -1}, {3, 4, 5}} </span></div><div class="line"><span class="comment">// sequences_batch_2 == {{-1, -1}, {6, 7}} </span></div><div class="line"><span class="comment">// sequence_masks_batch_1 == {{true, true, false}, {true, true, true}} </span></div><div class="line"><span class="comment">// sequence_masks_batch_2 == {{false, false}, {true, true}} </span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The column to be padded. </td></tr>
    <tr><td class="paramname">m</td><td>The column where the mask should be stored and from which the dimension is taken. </td></tr>
    <tr><td class="paramname">value</td><td>The value to pad with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pad_8hpp_source.html#l00090">90</a> of file <a class="el" href="pad_8hpp_source.html">pad.hpp</a>.</p>

</div>
</div>
<a id="ga43d752475cd1ba336c7a3650f7cdf12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d752475cd1ba336c7a3650f7cdf12b">&#9670;&nbsp;</a></span>random_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename ToColumn , typename Prng  = std::mt19937, typename Dist  = std::uniform_real_distribution&lt;double&gt;, int Dim = utility::ndims&lt;typename ToColumn::batch_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Dist(Prng&amp;)&gt;&gt;::value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::random_fill </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>size_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumn &gt;&#160;</td>
          <td class="paramname"><em>fill_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rnddims</em> = <code>std::numeric_limits&lt;long&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist&#160;</td>
          <td class="paramname"><em>dist</em> = <code>Dist{0,&#160;1}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prng &amp;&#160;</td>
          <td class="paramname"><em>prng</em> = <code>hipipe::utility::random_generator</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;Dim&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the selected column of a stream with random values. </p>
<p>This function uses <a class="el" href="group___vector.html#gaac4d8a7d79ece0155f2667cc5c31662c">stream::generate()</a> and has a similar semantics. That is, the column to be filled is first resized so that it has the same size as the selected source column.</p>
<p>Tip: If there is no column the size could be taken from, than just resize the target column manually and use it as both <code>from</code> column and <code>to</code> column.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 2};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id&gt;()</div><div class="line">  | <a class="code" href="group___vector.html#ga7002827c8f2bf0551767c6b5aa6a4e13">random_fill</a>(from&lt;id&gt;, to&lt;value&gt;);</div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;id, value&gt;, [](...){ ... });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_from</td><td>The column whose size will be used to initialize the random column. </td></tr>
    <tr><td class="paramname">fill_to</td><td>The column to be filled with random data. </td></tr>
    <tr><td class="paramname">rnddims</td><td>The number of random dimensions. See <a class="el" href="group___vector.html#ga7002827c8f2bf0551767c6b5aa6a4e13">utility::random_fill()</a>. </td></tr>
    <tr><td class="paramname">dist</td><td>The random distribution to be used. This object is copied on every use to avoid race conditions with <a class="el" href="group___stream.html#ga3cf6c7ccdd801356e7f6ea5fabb76db8">stream::buffer()</a>. </td></tr>
    <tr><td class="paramname">prng</td><td>The random generator to be used. </td></tr>
    <tr><td class="paramname">d</td><td>This is the dimension in which will the generator be applied. E.g., if set to 1, the generator result is considered to be a single example. The default is ndims&lt;ToColumn::batch_type&gt; - ndims&lt;dist(prng)&gt;. This value has to be positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random__fill_8hpp_source.html#l00056">56</a> of file <a class="el" href="random__fill_8hpp_source.html">random_fill.hpp</a>.</p>

</div>
</div>
<a id="ga86eb72187b1b478933826aed7c5b8f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86eb72187b1b478933826aed7c5b8f52">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a subset of hipipe columns to a different subset of hipipe columns. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id, value&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;id&gt;, to&lt;value&gt;, [](<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { <span class="keywordflow">return</span> <span class="keywordtype">id</span> * 5. + 1.; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. If the stream does not contain the selected columns, they are added to the stream. This parameter can overlap with the parameter f. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the target column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00178">178</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="gaeab8f89c1686645bed7e61fb5f46f104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab8f89c1686645bed7e61fb5f46f104">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename CondColumn , typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cond_t&lt; CondColumn &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditional transform of a subset of hipipe columns. </p>
<p>This function behaves the same as the original <a class="el" href="group___stream.html#ga5933ec8bbd6d6d3c9f41cbd16690c774" title="Probabilistic transform of a subset of hipipe columns. ">stream::transform()</a>, but it accepts one extra argument denoting a column of <code>true</code>/<code>false</code> values of the same shape as the columns to be transformed. The transformation will only be applied on true values and it will be an identity on false values.</p>
<p>Note that this can be very useful in combination with <a class="el" href="group___vector.html#ga7002827c8f2bf0551767c6b5aa6a4e13">stream::random_fill()</a> and <a href="http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution">std::bernoulli_distribution</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(dogs, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(do_trans, <span class="keywordtype">char</span>)  <span class="comment">// do not use bool here, vector&lt;bool&gt; is</span></div><div class="line">                                       <span class="comment">// not a good OutputRange</span></div><div class="line">std::vector&lt;int&gt; data_int = {3, 1, 5, 7};</div><div class="line"></div><div class="line"><span class="comment">// hardcoded usage</span></div><div class="line">std::vector&lt;int&gt; data_cond = {<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>};</div><div class="line"><span class="keyword">auto</span> rng = ranges::view::zip(data_int, data_cond)</div><div class="line">  | create&lt;dogs, do_trans&gt;()</div><div class="line">  <span class="comment">// this transforms only the first two examples and does nothing for the last two</span></div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; })</div><div class="line">  <span class="comment">// this transformation reverts the previous one</span></div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog - 1; });</div><div class="line"></div><div class="line"><span class="comment">// random_fill usage</span></div><div class="line">std::bernoulli_distribution dist{0.5};</div><div class="line"><span class="keyword">auto</span> rng2 = data_int</div><div class="line">  | create&lt;dogs&gt;()</div><div class="line">  | <a class="code" href="group___vector.html#ga7002827c8f2bf0551767c6b5aa6a4e13">random_fill</a>(from&lt;dogs&gt;, to&lt;do_trans&gt;, 1, dist, prng)</div><div class="line">  <span class="comment">// the transformation of each example is performed with 50% probability</span></div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; })</div><div class="line">  <span class="comment">// this transformation reverts the previous one</span></div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog - 1; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. Those have to already exist in the stream. </td></tr>
    <tr><td class="paramname">c</td><td>The column of <code>true</code>/<code>false</code> values denoting whether the transformation should be performed or not. For <code>false</code> values, the transformation is an identity on the target columns. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the selected column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00285">285</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="ga5933ec8bbd6d6d3c9f41cbd16690c774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5933ec8bbd6d6d3c9f41cbd16690c774">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename Fun , typename Prng  = std::mt19937, int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prng &amp;&#160;</td>
          <td class="paramname"><em>prng</em> = <code>utility::random_generator</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probabilistic transform of a subset of hipipe columns. </p>
<p>This function behaves the same as the original <a class="el" href="group___stream.html#ga5933ec8bbd6d6d3c9f41cbd16690c774" title="Probabilistic transform of a subset of hipipe columns. ">stream::transform()</a>, but it accepts one extra argument denoting the probability of transformation. If this probability is 0.0, the transformer behaves as an identity. If it is 1.0, the transofrmation function is always applied.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(dogs, <span class="keywordtype">int</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 5, 7};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;dogs&gt;()</div><div class="line">  <span class="comment">// In 50% of the cases, the number of dogs increase,</span></div><div class="line">  <span class="comment">// and in the other 50% of the cases, it stays the same.</span></div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, 0.5, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. Those have to already exist in the stream. </td></tr>
    <tr><td class="paramname">prob</td><td>The probability of transformation. If the dice roll fails, the transformer applies an identity on the target columns. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the selected column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">prng</td><td>The random generator to be used. Defaults to a thread_local std::mt19937. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00394">394</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="ga953e08640cd203ba8f39bb727e3a1acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953e08640cd203ba8f39bb727e3a1acf">&#9670;&nbsp;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename... FromColumns, int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hipipe::stream::unpack </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a stream into a tuple of ranges. </p>
<p>This operation transforms the stream (i.e., a range of tuples of columns) into a tuple of the types represented by the columns. The data can be unpacked in a specific dimension and then the higher dimensions are joined together.</p>
<p>If there is only a single column to be unpacked, the result is an std::vector of the corresponding type. If there are multiple columns to be unpacked, the result is a tuple of std::vectors.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(values, std::vector&lt;double&gt;)</div><div class="line"></div><div class="line">std::vector&lt;std::tuple&lt;int, std::vector&lt;double&gt;&gt;&gt; data = {{3, {5., 7.}}, {1, {2., 4.}}};</div><div class="line"><span class="keyword">auto</span> rng = data | create&lt;id, values&gt;(4);</div><div class="line"></div><div class="line"><span class="comment">// unpack in the first dimesion</span></div><div class="line">std::vector&lt;int&gt; unp_ids;</div><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; unp_values;</div><div class="line">std::tie(unp_ids, unp_values) = <a class="code" href="group___stream.html#ga953e08640cd203ba8f39bb727e3a1acf">unpack</a>(rng, from&lt;id, values&gt;);</div><div class="line"><span class="comment">// unp_ids == {3, 1}</span></div><div class="line"><span class="comment">// unp_values == {{5., 7.}, {2., 4.}}</span></div><div class="line"></div><div class="line"><span class="comment">// unpack a single column in the second dimesion</span></div><div class="line">std::vector&lt;double&gt; unp_values_dim2;</div><div class="line">unp_values_dim2 = <a class="code" href="group___stream.html#ga953e08640cd203ba8f39bb727e3a1acf">unpack</a>(rng, from&lt;values&gt;, dim&lt;2&gt;);</div><div class="line"><span class="comment">// unp_values_dim2 == {5., 7., 2., 4.}</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="unpack_8hpp_source.html#l00101">101</a> of file <a class="el" href="unpack_8hpp_source.html">unpack.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga31e083506fa747e23bee7f76b9a88814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e083506fa747e23bee7f76b9a88814">&#9670;&nbsp;</a></span>batch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ranges::view::view&lt;batch_fn&gt; hipipe::stream::batch {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate the stream and yield batches of a different size. </p>
<p>The batch size of the accumulated columns is allowed to differ between batches. To make one large batch of all the data, use std::numeric_limits&lt;std::size_t&gt;::max().</p>
<div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">int</span>)</div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10)</div><div class="line">  | create&lt;value&gt;(2)  <span class="comment">// batches the data by two examples</span></div><div class="line">  | <a class="code" href="group___stream.html#ga31e083506fa747e23bee7f76b9a88814">batch</a>(3);         <span class="comment">// changes the batch size to three examples</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="batch_8hpp_source.html#l00201">201</a> of file <a class="el" href="batch_8hpp_source.html">batch.hpp</a>.</p>

</div>
</div>
<a id="ga3cf6c7ccdd801356e7f6ea5fabb76db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cf6c7ccdd801356e7f6ea5fabb76db8">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ranges::view::view&lt;buffer_fn&gt; hipipe::stream::buffer {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously buffers the given range. </p>
<p>Asynchronously evaluates the given number of elements in advance. When queried for the next element, it is already prepared. This view works for any range, not only for hipipe streams.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};</div><div class="line"><span class="keyword">auto</span> buffered_rng = data</div><div class="line">  | <a class="code" href="group___stream.html#ga86eb72187b1b478933826aed7c5b8f52">ranges::view::transform</a>([](<span class="keywordtype">int</span> v) { <span class="keywordflow">return</span> v + 1; })</div><div class="line">  | <a class="code" href="group___stream.html#ga3cf6c7ccdd801356e7f6ea5fabb76db8">buffer</a>(2);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00162">162</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="gae56891f9101f14ac09d0d247f6b79c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56891f9101f14ac09d0d247f6b79c24">&#9670;&nbsp;</a></span>create</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr ranges::view::view&lt;detail::create_fn&lt;Columns...&gt; &gt; hipipe::stream::create {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a range to a stream (i.e., to a range of tuples of columns). </p>
<p>The value type of the input range is supposed to be either the type represented by the column to be created, or a tuple of such types if there are more columns to be created.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(age, <span class="keywordtype">int</span>)</div><div class="line"></div><div class="line"><span class="comment">// rng is a stream where each batch is a single element from 0..9</span></div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10) | create&lt;id&gt;();</div><div class="line"></div><div class="line"><span class="comment">// batched_rng is a stream with a single batch with numbers 0..9</span></div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10) | create&lt;id&gt;(50);</div><div class="line"></div><div class="line"><span class="comment">// also multiple columns can be created at once</span></div><div class="line"><span class="keyword">auto</span> rng = view::zip(view::iota(0, 10), view::iota(30, 50)) | create&lt;id, age&gt;();</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch_size</td><td>The requested batch size for the provided data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="create_8hpp_source.html#l00090">90</a> of file <a class="el" href="create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="ga5649697e86eea6020c2035777f98c1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5649697e86eea6020c2035777f98c1be">&#9670;&nbsp;</a></span>drop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr ranges::view::view&lt;detail::drop_fn&lt;Columns...&gt; &gt; hipipe::stream::drop {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops columns from a stream. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#gacf90e1f464c32aa14857b51f72e685ee">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data | create&lt;id, value&gt;() | drop&lt;id&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="drop_8hpp_source.html#l00078">78</a> of file <a class="el" href="drop_8hpp_source.html">drop.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
