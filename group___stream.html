<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HiPipe: Stream modifiers and data types.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HiPipe
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">C++17 data pipeline with Python bindings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Stream modifiers and data types.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhipipe_1_1stream_1_1batch.html">hipipe::stream::batch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for multiple columns.  <a href="classhipipe_1_1stream_1_1batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhipipe_1_1stream_1_1abstract__column.html">hipipe::stream::abstract_column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for HiPipe columns.  <a href="classhipipe_1_1stream_1_1abstract__column.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base&lt; ColumnName, ExampleType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation stub of a column defined by HIPIPE_DEFINE_COLUMN macro.  <a href="classhipipe_1_1stream_1_1column__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga762e4b9643b235eec42b86533e3302da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(column_name_,  example_type_)</td></tr>
<tr class="memdesc:ga762e4b9643b235eec42b86533e3302da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for fast column definition.  <a href="#ga762e4b9643b235eec42b86533e3302da">More...</a><br /></td></tr>
<tr class="separator:ga762e4b9643b235eec42b86533e3302da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf31423b698a6dbb4929ce67fd7dd4286"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#gaf31423b698a6dbb4929ce67fd7dd4286">hipipe::stream::forward_stream_t</a> = ranges::any_view&lt; <a class="el" href="classhipipe_1_1stream_1_1batch.html">batch_t</a>, ranges::category::forward &gt;</td></tr>
<tr class="memdesc:gaf31423b698a6dbb4929ce67fd7dd4286"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream itself, i.e., a range of batches.  <a href="group___stream.html#gaf31423b698a6dbb4929ce67fd7dd4286">More...</a><br /></td></tr>
<tr class="separator:gaf31423b698a6dbb4929ce67fd7dd4286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1fbadb8f5dee2b816e8dcd8bda8af0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#ga2d1fbadb8f5dee2b816e8dcd8bda8af0">hipipe::stream::input_stream_t</a> = ranges::any_view&lt; <a class="el" href="classhipipe_1_1stream_1_1batch.html">batch_t</a>, ranges::category::input &gt;</td></tr>
<tr class="memdesc:ga2d1fbadb8f5dee2b816e8dcd8bda8af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream type after special eager operations.  <a href="group___stream.html#ga2d1fbadb8f5dee2b816e8dcd8bda8af0">More...</a><br /></td></tr>
<tr class="separator:ga2d1fbadb8f5dee2b816e8dcd8bda8af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41c2acf41cda5437ee5d73cac67266cf"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns&gt; </td></tr>
<tr class="memitem:ga41c2acf41cda5437ee5d73cac67266cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga41c2acf41cda5437ee5d73cac67266cf">hipipe::stream::copy</a> (from_t&lt; FromColumns... &gt; from_cols, to_t&lt; ToColumns... &gt; to_cols)</td></tr>
<tr class="memdesc:ga41c2acf41cda5437ee5d73cac67266cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the data from FromColumns to the respective ToColumns.  <a href="group___stream.html#ga41c2acf41cda5437ee5d73cac67266cf">More...</a><br /></td></tr>
<tr class="separator:ga41c2acf41cda5437ee5d73cac67266cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9623ff6d664422fb96e7fedd47c1cf"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ByColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:gada9623ff6d664422fb96e7fedd47c1cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gada9623ff6d664422fb96e7fedd47c1cf">hipipe::stream::filter</a> (from_t&lt; FromColumns... &gt; f, by_t&lt; ByColumns... &gt; b, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:gada9623ff6d664422fb96e7fedd47c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter stream data.  <a href="group___stream.html#gada9623ff6d664422fb96e7fedd47c1cf">More...</a><br /></td></tr>
<tr class="separator:gada9623ff6d664422fb96e7fedd47c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f25e82e288e6b384faf667ff20ae2d"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:ga42f25e82e288e6b384faf667ff20ae2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga42f25e82e288e6b384faf667ff20ae2d">hipipe::stream::for_each</a> (from_t&lt; FromColumns... &gt; f, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga42f25e82e288e6b384faf667ff20ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a subset of stream columns.  <a href="group___stream.html#ga42f25e82e288e6b384faf667ff20ae2d">More...</a><br /></td></tr>
<tr class="separator:ga42f25e82e288e6b384faf667ff20ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0626fc6895eaa994868fcd29d2ffdd74"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename ToColumn , typename Gen , int Dim = utility::ndims&lt;typename ToColumn::data_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Gen()&gt;&gt;::value&gt; </td></tr>
<tr class="memitem:ga0626fc6895eaa994868fcd29d2ffdd74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">hipipe::stream::generate</a> (from_t&lt; FromColumn &gt; size_from, to_t&lt; ToColumn &gt; fill_to, Gen gen, long gendims=std::numeric_limits&lt; long &gt;::max(), dim_t&lt; Dim &gt; d=dim_t&lt; Dim &gt;{})</td></tr>
<tr class="memdesc:ga0626fc6895eaa994868fcd29d2ffdd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the selected column using a generator (i.e., a nullary function).  <a href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">More...</a><br /></td></tr>
<tr class="separator:ga0626fc6895eaa994868fcd29d2ffdd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a2d18b3f73e45047b2371d16a4f59a"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename MaskColumn , typename ValT  = typename utility::ndim_type_t&lt;      typename FromColumn::data_type,       utility::ndims&lt;typename MaskColumn::data_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gac0a2d18b3f73e45047b2371d16a4f59a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gac0a2d18b3f73e45047b2371d16a4f59a">hipipe::stream::pad</a> (from_t&lt; FromColumn &gt; f, mask_t&lt; MaskColumn &gt; m, ValT value=ValT{})</td></tr>
<tr class="memdesc:gac0a2d18b3f73e45047b2371d16a4f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the selected column to a rectangular size.  <a href="group___stream.html#gac0a2d18b3f73e45047b2371d16a4f59a">More...</a><br /></td></tr>
<tr class="separator:gac0a2d18b3f73e45047b2371d16a4f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a63d49ca098364d5d43838844ae354"><td class="memTemplParams" colspan="2">template&lt;typename FromColumn , typename ToColumn , typename Prng  = std::mt19937, typename Dist  = std::uniform_real_distribution&lt;double&gt;, int Dim = utility::ndims&lt;typename ToColumn::data_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Dist(Prng&amp;)&gt;&gt;::value&gt; </td></tr>
<tr class="memitem:ga92a63d49ca098364d5d43838844ae354"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">hipipe::stream::random_fill</a> (from_t&lt; FromColumn &gt; size_from, to_t&lt; ToColumn &gt; fill_to, long rnddims=std::numeric_limits&lt; long &gt;::max(), Dist dist=Dist{0, 1}, Prng &amp;prng=hipipe::utility::random_generator, dim_t&lt; Dim &gt; d=dim_t&lt; Dim &gt;{})</td></tr>
<tr class="memdesc:ga92a63d49ca098364d5d43838844ae354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the selected column of a stream with random values.  <a href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">More...</a><br /></td></tr>
<tr class="separator:ga92a63d49ca098364d5d43838844ae354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf7aa0a0a0d369f631e4d99f8902397"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:gabdf7aa0a0a0d369f631e4d99f8902397"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:gabdf7aa0a0a0d369f631e4d99f8902397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a subset of hipipe columns to a different subset of hipipe columns.  <a href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">More...</a><br /></td></tr>
<tr class="separator:gabdf7aa0a0a0d369f631e4d99f8902397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb442e05bda5dfb7fbaef762b1415c2"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename CondColumn , typename Fun , int Dim = 1&gt; </td></tr>
<tr class="memitem:gabfb442e05bda5dfb7fbaef762b1415c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gabfb442e05bda5dfb7fbaef762b1415c2">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, cond_t&lt; CondColumn &gt; c, Fun fun, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:gabfb442e05bda5dfb7fbaef762b1415c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional transform of a subset of hipipe columns.  <a href="group___stream.html#gabfb442e05bda5dfb7fbaef762b1415c2">More...</a><br /></td></tr>
<tr class="separator:gabfb442e05bda5dfb7fbaef762b1415c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fb47a61e101ca8ba218b32e6523b4b"><td class="memTemplParams" colspan="2">template&lt;typename... FromColumns, typename... ToColumns, typename Fun , typename Prng  = std::mt19937, int Dim = 1&gt; </td></tr>
<tr class="memitem:ga13fb47a61e101ca8ba218b32e6523b4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga13fb47a61e101ca8ba218b32e6523b4b">hipipe::stream::transform</a> (from_t&lt; FromColumns... &gt; f, to_t&lt; ToColumns... &gt; t, double prob, Fun fun, Prng &amp;prng=utility::random_generator, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga13fb47a61e101ca8ba218b32e6523b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probabilistic transform of a subset of hipipe columns.  <a href="group___stream.html#ga13fb47a61e101ca8ba218b32e6523b4b">More...</a><br /></td></tr>
<tr class="separator:ga13fb47a61e101ca8ba218b32e6523b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54df38e632e838f717054fb9df545200"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename... FromColumns, int Dim = 1&gt; </td></tr>
<tr class="memitem:ga54df38e632e838f717054fb9df545200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga54df38e632e838f717054fb9df545200">hipipe::stream::unpack</a> (Rng &amp;&amp;rng, from_t&lt; FromColumns... &gt; f, dim_t&lt; Dim &gt; d=dim_t&lt; 1 &gt;{})</td></tr>
<tr class="memdesc:ga54df38e632e838f717054fb9df545200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a stream into a tuple of ranges.  <a href="group___stream.html#ga54df38e632e838f717054fb9df545200">More...</a><br /></td></tr>
<tr class="separator:ga54df38e632e838f717054fb9df545200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad2959b9ed9c589f9f493ecd2198abdf2"><td class="memItemLeft" align="right" valign="top">ranges::view::view&lt; buffer_fn &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#gad2959b9ed9c589f9f493ecd2198abdf2">hipipe::stream::buffer</a> {}</td></tr>
<tr class="memdesc:gad2959b9ed9c589f9f493ecd2198abdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously buffers the given range.  <a href="group___stream.html#gad2959b9ed9c589f9f493ecd2198abdf2">More...</a><br /></td></tr>
<tr class="separator:gad2959b9ed9c589f9f493ecd2198abdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05dc07f4ec4ef94a891ab95c5939dc0"><td class="memTemplParams" colspan="2">template&lt;typename... Columns&gt; </td></tr>
<tr class="memitem:gad05dc07f4ec4ef94a891ab95c5939dc0"><td class="memTemplItemLeft" align="right" valign="top">ranges::view::view&lt; detail::create_fn&lt; Columns... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#gad05dc07f4ec4ef94a891ab95c5939dc0">hipipe::stream::create</a> {}</td></tr>
<tr class="memdesc:gad05dc07f4ec4ef94a891ab95c5939dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a data range to a HiPipe stream.  <a href="group___stream.html#gad05dc07f4ec4ef94a891ab95c5939dc0">More...</a><br /></td></tr>
<tr class="separator:gad05dc07f4ec4ef94a891ab95c5939dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7322d5bcc2c24a6b3537940c286ba8f5"><td class="memTemplParams" colspan="2">template&lt;typename... Columns&gt; </td></tr>
<tr class="memitem:ga7322d5bcc2c24a6b3537940c286ba8f5"><td class="memTemplItemLeft" align="right" valign="top">ranges::view::view&lt; detail::drop_fn&lt; Columns... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga7322d5bcc2c24a6b3537940c286ba8f5">hipipe::stream::drop</a> {}</td></tr>
<tr class="memdesc:ga7322d5bcc2c24a6b3537940c286ba8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops columns from a stream.  <a href="group___stream.html#ga7322d5bcc2c24a6b3537940c286ba8f5">More...</a><br /></td></tr>
<tr class="separator:ga7322d5bcc2c24a6b3537940c286ba8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0cef72ffbd8f645a067ddb4b98149b"><td class="memTemplParams" colspan="2">template&lt;typename... Columns&gt; </td></tr>
<tr class="memitem:ga2e0cef72ffbd8f645a067ddb4b98149b"><td class="memTemplItemLeft" align="right" valign="top">ranges::view::view&lt; detail::keep_fn&lt; Columns... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___stream.html#ga2e0cef72ffbd8f645a067ddb4b98149b">hipipe::stream::keep</a> {}</td></tr>
<tr class="memdesc:ga2e0cef72ffbd8f645a067ddb4b98149b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep the specified columns in the stream, drop everything else.  <a href="group___stream.html#ga2e0cef72ffbd8f645a067ddb4b98149b">More...</a><br /></td></tr>
<tr class="separator:ga2e0cef72ffbd8f645a067ddb4b98149b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60d28c3d0e6fcaa19ee75b412f56243"><td class="memItemLeft" align="right" valign="top">ranges::view::view&lt; rebatch_fn &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___stream.html#gaa60d28c3d0e6fcaa19ee75b412f56243">hipipe::stream::rebatch</a> {}</td></tr>
<tr class="memdesc:gaa60d28c3d0e6fcaa19ee75b412f56243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate the stream and yield batches of a different size.  <a href="group___stream.html#gaa60d28c3d0e6fcaa19ee75b412f56243">More...</a><br /></td></tr>
<tr class="separator:gaa60d28c3d0e6fcaa19ee75b412f56243"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga762e4b9643b235eec42b86533e3302da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762e4b9643b235eec42b86533e3302da">&#9670;&nbsp;</a></span>HIPIPE_DEFINE_COLUMN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HIPIPE_DEFINE_COLUMN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">column_name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">example_type_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>column_name_ : <a class="code" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base</a>&lt;column_name_, example_type_&gt; {  \</div><div class="line">    using <a class="code" href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base&lt;column_name_, example_type_&gt;::column_base</a>;  \</div><div class="line">    std::string <a class="code" href="classhipipe_1_1stream_1_1abstract__column.html#ac597cb596daec9ed1724a4efd4188823">name</a>()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> #column_name_; }                   \</div><div class="line">};</div><div class="ttc" id="classhipipe_1_1stream_1_1abstract__column_html_ac597cb596daec9ed1724a4efd4188823"><div class="ttname"><a href="classhipipe_1_1stream_1_1abstract__column.html#ac597cb596daec9ed1724a4efd4188823">hipipe::stream::abstract_column::name</a></div><div class="ttdeci">virtual std::string name() const =0</div></div>
<div class="ttc" id="classhipipe_1_1stream_1_1column__base_html"><div class="ttname"><a href="classhipipe_1_1stream_1_1column__base.html">hipipe::stream::column_base</a></div><div class="ttdoc">Implementation stub of a column defined by HIPIPE_DEFINE_COLUMN macro.</div><div class="ttdef"><b>Definition:</b> <a href="column__t_8hpp_source.html#l00121">column_t.hpp:121</a></div></div>
</div><!-- fragment -->
<p>Macro for fast column definition. </p>
<p>Under the hood, it creates a new type derived from column_base. </p>

<p class="definition">Definition at line <a class="el" href="column__t_8hpp_source.html#l00251">251</a> of file <a class="el" href="column__t_8hpp_source.html">column_t.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf31423b698a6dbb4929ce67fd7dd4286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31423b698a6dbb4929ce67fd7dd4286">&#9670;&nbsp;</a></span>forward_stream_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___stream.html#gaf31423b698a6dbb4929ce67fd7dd4286">hipipe::stream::forward_stream_t</a> = typedef ranges::any_view&lt;<a class="el" href="classhipipe_1_1stream_1_1batch.html">batch_t</a>, ranges::category::forward&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream itself, i.e., a range of batches. </p>
<p>Unless specified otherwise, the stream transformers expect this type and return this type. Exceptions are e.g. <a class="el" href="group___stream.html">Stream modifiers and data types.</a> stream::rebatch. </p>

<p class="definition">Definition at line <a class="el" href="stream__t_8hpp_source.html#l00024">24</a> of file <a class="el" href="stream__t_8hpp_source.html">stream_t.hpp</a>.</p>

</div>
</div>
<a id="ga2d1fbadb8f5dee2b816e8dcd8bda8af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d1fbadb8f5dee2b816e8dcd8bda8af0">&#9670;&nbsp;</a></span>input_stream_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___stream.html#ga2d1fbadb8f5dee2b816e8dcd8bda8af0">hipipe::stream::input_stream_t</a> = typedef ranges::any_view&lt;<a class="el" href="classhipipe_1_1stream_1_1batch.html">batch_t</a>, ranges::category::input&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream type after special eager operations. </p>
<p>For instance, stream::rebatch reduces the stream to InputRange and returns this type. Stream of such type cannot be further transformed. </p>

<p class="definition">Definition at line <a class="el" href="stream__t_8hpp_source.html#l00032">32</a> of file <a class="el" href="stream__t_8hpp_source.html">stream_t.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga41c2acf41cda5437ee5d73cac67266cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c2acf41cda5437ee5d73cac67266cf">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::copy </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>from_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>to_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the data from FromColumns to the respective ToColumns. </p>
<p>The data from i-th FromColumn are copied to i-th ToColumn. Note that the ToColumns examples must be constructible from their FromColumns counterparts.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(i, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(i2, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(i3, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(l, <span class="keywordtype">long</span>)</div><div class="line"></div><div class="line"><span class="comment">// rng is a stream with four identical columns</span></div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10) | create&lt;i&gt;() |</div><div class="line">  <a class="code" href="group___stream.html#ga41c2acf41cda5437ee5d73cac67266cf">copy</a>(from&lt;i&gt;, to&lt;i2&gt;) | <a class="code" href="group___stream.html#ga41c2acf41cda5437ee5d73cac67266cf">copy</a>(from&lt;i, i2&gt;, to&lt;i3, l&gt;);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_cols</td><td>The source columns. </td></tr>
    <tr><td class="paramname">to_cols</td><td>The target columns. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="copy_8hpp_source.html#l00038">38</a> of file <a class="el" href="copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gada9623ff6d664422fb96e7fedd47c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9623ff6d664422fb96e7fedd47c1cf">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ByColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::filter </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">by_t&lt; ByColumns... &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter stream data. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id, value&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#gada9623ff6d664422fb96e7fedd47c1cf">filter</a>(from&lt;id, value&gt;, by&lt;value&gt;, [](<span class="keywordtype">double</span> value) { <span class="keywordflow">return</span> value &gt; 3.; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be filtered. </td></tr>
    <tr><td class="paramname">b</td><td>The columns to be passed to the filtering function. Those have to be a subset of f. </td></tr>
    <tr><td class="paramname">fun</td><td>The filtering function returning a boolean. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which the function is applied. Choose 0 to filter whole batches (in such a case, the f parameter is ignored). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="filter_8hpp_source.html#l00141">141</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a id="ga42f25e82e288e6b384faf667ff20ae2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f25e82e288e6b384faf667ff20ae2d">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::for_each </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to a subset of stream columns. </p>
<p>The given function is applied to a subset of columns given by FromColumns. The function is applied lazily, i.e., only when the range is iterated.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(Int, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(Double, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;Int, Double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | <a class="code" href="group___stream.html#ga42f25e82e288e6b384faf667ff20ae2d">for_each</a>(from&lt;Int, Double&gt;, [](<span class="keywordtype">int</span>&amp; v, <span class="keywordtype">double</span>&amp; d) { std::cout &lt;&lt; c + d; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be exctracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which the function is applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="for__each_8hpp_source.html#l00062">62</a> of file <a class="el" href="for__each_8hpp_source.html">for_each.hpp</a>.</p>

</div>
</div>
<a id="ga0626fc6895eaa994868fcd29d2ffdd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0626fc6895eaa994868fcd29d2ffdd74">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename ToColumn , typename Gen , int Dim = utility::ndims&lt;typename ToColumn::data_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Gen()&gt;&gt;::value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::generate </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>size_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumn &gt;&#160;</td>
          <td class="paramname"><em>fill_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>gendims</em> = <code>std::numeric_limits&lt;long&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;Dim&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the selected column using a generator (i.e., a nullary function). </p>
<p>This function uses <a class="el" href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">utility::generate()</a>. Furthermore, the column to be filled is first resized so that it has the same size as the selected source column.</p>
<p>Tip: If there is no column the size could be taken from, than just resize the target column manually and use it as both <code>from</code> column and <code>to</code> column.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 2};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id&gt;()</div><div class="line">  <span class="comment">// assign each id a value from an increasing sequence</span></div><div class="line">  | <a class="code" href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">generate</a>(from&lt;id&gt;, to&lt;value&gt;, [i = 0]() <span class="keyword">mutable</span> { <span class="keywordflow">return</span> i++; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_from</td><td>The column whose size will be used to initialize the generated column. </td></tr>
    <tr><td class="paramname">fill_to</td><td>The column to be filled using the generator. </td></tr>
    <tr><td class="paramname">gen</td><td>The generator to be used. </td></tr>
    <tr><td class="paramname">gendims</td><td>The number of generated dimensions. See <a class="el" href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">utility::generate()</a>. </td></tr>
    <tr><td class="paramname">d</td><td>This is the dimension in which will the generator be applied. E.g., if set to 1, the generator result is considered to be a single example. The default is ndims&lt;ToColumn::data_type&gt; - ndims&lt;gen()&gt;. This value has to be positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate_8hpp_source.html#l00083">83</a> of file <a class="el" href="generate_8hpp_source.html">generate.hpp</a>.</p>

</div>
</div>
<a id="gac0a2d18b3f73e45047b2371d16a4f59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0a2d18b3f73e45047b2371d16a4f59a">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename MaskColumn , typename ValT  = typename utility::ndim_type_t&lt;      typename FromColumn::data_type,       utility::ndims&lt;typename MaskColumn::data_type&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::pad </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_t&lt; MaskColumn &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValT&#160;</td>
          <td class="paramname"><em>value</em> = <code>ValT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the selected column to a rectangular size. </p>
<p>Each batch is padded separately.</p>
<p>The mask of the padded values is created along with the padding. The mask evaluates to <code>true</code> on the positions with the original elements and to <code>false</code> on the positions of the padded elements. The mask column should be a multidimensional vector of type bool/char/int/... The dimensionality of the mask column is used to deduce how many dimensions should be padded in the source column.</p>
<p>This transformer internally uses <a class="el" href="group___n_dim.html#ga1e31cc4e4c45bdae53e78174cc215269">utility::ndim_pad()</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(sequences, std::vector&lt;int&gt;)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(sequence_masks, std::vector&lt;bool&gt;)</div><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; data = {{1, 2}, {3, 4, 5}, {}, {6, 7}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;sequences&gt;(2)</div><div class="line">  | <a class="code" href="group___stream.html#gac0a2d18b3f73e45047b2371d16a4f59a">pad</a>(from&lt;sequences&gt;, mask&lt;sequence_masks&gt;, -1);</div><div class="line"><span class="comment">// sequences_batch_1 == {{1, 2, -1}, {3, 4, 5}} </span></div><div class="line"><span class="comment">// sequences_batch_2 == {{-1, -1}, {6, 7}} </span></div><div class="line"><span class="comment">// sequence_masks_batch_1 == {{true, true, false}, {true, true, true}} </span></div><div class="line"><span class="comment">// sequence_masks_batch_2 == {{false, false}, {true, true}} </span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The column to be padded. </td></tr>
    <tr><td class="paramname">m</td><td>The column where the mask should be stored and from which the dimension is taken. </td></tr>
    <tr><td class="paramname">value</td><td>The value to pad with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pad_8hpp_source.html#l00090">90</a> of file <a class="el" href="pad_8hpp_source.html">pad.hpp</a>.</p>

</div>
</div>
<a id="ga92a63d49ca098364d5d43838844ae354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a63d49ca098364d5d43838844ae354">&#9670;&nbsp;</a></span>random_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromColumn , typename ToColumn , typename Prng  = std::mt19937, typename Dist  = std::uniform_real_distribution&lt;double&gt;, int Dim = utility::ndims&lt;typename ToColumn::data_type&gt;::value - utility::ndims&lt;std::result_of_t&lt;Dist(Prng&amp;)&gt;&gt;::value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::random_fill </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumn &gt;&#160;</td>
          <td class="paramname"><em>size_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumn &gt;&#160;</td>
          <td class="paramname"><em>fill_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rnddims</em> = <code>std::numeric_limits&lt;long&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist&#160;</td>
          <td class="paramname"><em>dist</em> = <code>Dist{0,&#160;1}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prng &amp;&#160;</td>
          <td class="paramname"><em>prng</em> = <code>hipipe::utility::random_generator</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;Dim&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the selected column of a stream with random values. </p>
<p>This function uses <a class="el" href="group___stream.html#ga0626fc6895eaa994868fcd29d2ffdd74">stream::generate()</a> and has a similar semantics. That is, the column to be filled is first resized so that it has the same size as the selected source column.</p>
<p>Tip: If there is no column the size could be taken from, than just resize the target column manually and use it as both <code>from</code> column and <code>to</code> column.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 2};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">random_fill</a>(from&lt;id&gt;, to&lt;value&gt;);</div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;id, value&gt;, [](...){ ... });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_from</td><td>The column whose size will be used to initialize the random column. </td></tr>
    <tr><td class="paramname">fill_to</td><td>The column to be filled with random data. </td></tr>
    <tr><td class="paramname">rnddims</td><td>The number of random dimensions. See <a class="el" href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">utility::random_fill()</a>. </td></tr>
    <tr><td class="paramname">dist</td><td>The random distribution to be used. This object is copied on every use to avoid race conditions with <a class="el" href="group___stream.html#gad2959b9ed9c589f9f493ecd2198abdf2">stream::buffer()</a>. </td></tr>
    <tr><td class="paramname">prng</td><td>The random generator to be used. </td></tr>
    <tr><td class="paramname">d</td><td>This is the dimension in which will the generator be applied. E.g., if set to 1, the generator result is considered to be a single example. The default is ndims&lt;ToColumn::data_type&gt; - ndims&lt;dist(prng)&gt;. This value has to be positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random__fill_8hpp_source.html#l00052">52</a> of file <a class="el" href="random__fill_8hpp_source.html">random_fill.hpp</a>.</p>

</div>
</div>
<a id="gabdf7aa0a0a0d369f631e4d99f8902397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf7aa0a0a0d369f631e4d99f8902397">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a subset of hipipe columns to a different subset of hipipe columns. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;id, value&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;id&gt;, to&lt;value&gt;, [](<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { <span class="keywordflow">return</span> <span class="keywordtype">id</span> * 5. + 1.; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. If the stream does not contain the selected columns, they are added to the stream. This parameter can overlap with the parameter f. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the target column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00187">187</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="gabfb442e05bda5dfb7fbaef762b1415c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfb442e05bda5dfb7fbaef762b1415c2">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename CondColumn , typename Fun , int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cond_t&lt; CondColumn &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditional transform of a subset of hipipe columns. </p>
<p>This function behaves the same as the original <a class="el" href="group___stream.html#ga13fb47a61e101ca8ba218b32e6523b4b" title="Probabilistic transform of a subset of hipipe columns.">stream::transform()</a>, but it accepts one extra argument denoting a column of <code>true</code>/<code>false</code> values of the same shape as the columns to be transformed. The transformation will only be applied on true values and it will be an identity on false values.</p>
<p>Note that this can be very useful in combination with <a class="el" href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">stream::random_fill()</a> and <a href="http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution">std::bernoulli_distribution</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(dogs, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(do_trans, <span class="keywordtype">char</span>)  <span class="comment">// do not use bool here, vector&lt;bool&gt; is</span></div><div class="line">                                       <span class="comment">// not a good OutputRange</span></div><div class="line">std::vector&lt;int&gt; data_int = {3, 1, 5, 7};</div><div class="line"></div><div class="line"><span class="comment">// hardcoded usage</span></div><div class="line">std::vector&lt;int&gt; data_cond = {<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>};</div><div class="line"><span class="keyword">auto</span> rng = ranges::view::zip(data_int, data_cond)</div><div class="line">  | create&lt;dogs, do_trans&gt;()</div><div class="line">  <span class="comment">// this transforms only the first two examples and does nothing for the last two</span></div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; })</div><div class="line">  <span class="comment">// this transformation reverts the previous one</span></div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog - 1; });</div><div class="line"></div><div class="line"><span class="comment">// random_fill usage</span></div><div class="line">std::bernoulli_distribution dist{0.5};</div><div class="line"><span class="keyword">auto</span> rng2 = data_int</div><div class="line">  | create&lt;dogs&gt;()</div><div class="line">  | <a class="code" href="group___stream.html#ga92a63d49ca098364d5d43838844ae354">random_fill</a>(from&lt;dogs&gt;, to&lt;do_trans&gt;, 1, dist, prng)</div><div class="line">  <span class="comment">// the transformation of each example is performed with 50% probability</span></div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; })</div><div class="line">  <span class="comment">// this transformation reverts the previous one</span></div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, cond&lt;do_trans&gt;, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog - 1; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. Those have to already exist in the stream. </td></tr>
    <tr><td class="paramname">c</td><td>The column of <code>true</code>/<code>false</code> values denoting whether the transformation should be performed or not. For <code>false</code> values, the transformation is an identity on the target columns. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the selected column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00314">314</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="ga13fb47a61e101ca8ba218b32e6523b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fb47a61e101ca8ba218b32e6523b4b">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FromColumns, typename... ToColumns, typename Fun , typename Prng  = std::mt19937, int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::transform </td>
          <td>(</td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to_t&lt; ToColumns... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prng &amp;&#160;</td>
          <td class="paramname"><em>prng</em> = <code>utility::random_generator</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probabilistic transform of a subset of hipipe columns. </p>
<p>This function behaves the same as the original <a class="el" href="group___stream.html#ga13fb47a61e101ca8ba218b32e6523b4b" title="Probabilistic transform of a subset of hipipe columns.">stream::transform()</a>, but it accepts one extra argument denoting the probability of transformation. If this probability is 0.0, the transformer behaves as an identity. If it is 1.0, the transofrmation function is always applied.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(dogs, <span class="keywordtype">int</span>)</div><div class="line">std::vector&lt;int&gt; data = {3, 1, 5, 7};</div><div class="line"><span class="keyword">auto</span> rng = data</div><div class="line">  | create&lt;dogs&gt;()</div><div class="line">  <span class="comment">// In 50% of the cases, the number of dogs increase,</span></div><div class="line">  <span class="comment">// and in the other 50% of the cases, it stays the same.</span></div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">transform</a>(from&lt;dogs&gt;, to&lt;dogs&gt;, 0.5, [](<span class="keywordtype">int</span> dog) { <span class="keywordflow">return</span> dog + 1; });</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The columns to be extracted out of the tuple of columns and passed to fun. </td></tr>
    <tr><td class="paramname">t</td><td>The columns where the result will be saved. Those have to already exist in the stream. </td></tr>
    <tr><td class="paramname">prob</td><td>The probability of transformation. If the dice roll fails, the transformer applies an identity on the target columns. </td></tr>
    <tr><td class="paramname">fun</td><td>The function to be applied. The function should return the type represented by the selected column in the given dimension. If there are multiple target columns, the function should return a tuple of the corresponding types. </td></tr>
    <tr><td class="paramname">prng</td><td>The random generator to be used. Defaults to a thread_local std::mt19937. </td></tr>
    <tr><td class="paramname">d</td><td>The dimension in which is the function applied. Choose 0 for the function to be applied to the whole batch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8hpp_source.html#l00443">443</a> of file <a class="el" href="transform_8hpp_source.html">transform.hpp</a>.</p>

</div>
</div>
<a id="ga54df38e632e838f717054fb9df545200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54df38e632e838f717054fb9df545200">&#9670;&nbsp;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename... FromColumns, int Dim = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hipipe::stream::unpack </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">from_t&lt; FromColumns... &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>d</em> = <code>dim_t&lt;1&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a stream into a tuple of ranges. </p>
<p>This operation transforms the stream (i.e., a range of batches) into a tuple of the types represented by the columns. The data can be unpacked in a specific dimension and then the higher dimensions are joined together.</p>
<p>If there is only a single column to be unpacked, the result is an std::vector of the corresponding type. If there are multiple columns to be unpacked, the result is a tuple of std::vectors.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(values, std::vector&lt;double&gt;)</div><div class="line"></div><div class="line">std::vector&lt;std::tuple&lt;int, std::vector&lt;double&gt;&gt;&gt; data = {{3, {5., 7.}}, {1, {2., 4.}}};</div><div class="line"><span class="keyword">auto</span> rng = data | create&lt;id, values&gt;(4);</div><div class="line"></div><div class="line"><span class="comment">// unpack in the first dimesion</span></div><div class="line">std::vector&lt;int&gt; unp_ids;</div><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; unp_values;</div><div class="line">std::tie(unp_ids, unp_values) = <a class="code" href="group___stream.html#ga54df38e632e838f717054fb9df545200">unpack</a>(rng, from&lt;id, values&gt;);</div><div class="line"><span class="comment">// unp_ids == {3, 1}</span></div><div class="line"><span class="comment">// unp_values == {{5., 7.}, {2., 4.}}</span></div><div class="line"></div><div class="line"><span class="comment">// unpack a single column in the second dimesion</span></div><div class="line">std::vector&lt;double&gt; unp_values_dim2;</div><div class="line">unp_values_dim2 = <a class="code" href="group___stream.html#ga54df38e632e838f717054fb9df545200">unpack</a>(rng, from&lt;values&gt;, dim&lt;2&gt;);</div><div class="line"><span class="comment">// unp_values_dim2 == {5., 7., 2., 4.}</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="unpack_8hpp_source.html#l00110">110</a> of file <a class="el" href="unpack_8hpp_source.html">unpack.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad2959b9ed9c589f9f493ecd2198abdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2959b9ed9c589f9f493ecd2198abdf2">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ranges::view::view&lt;buffer_fn&gt; hipipe::stream::buffer {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously buffers the given range. </p>
<p>Asynchronously evaluates the given number of elements in advance. When queried for the next element, it is already prepared. This view works for any range, not only for hipipe streams.</p>
<p>Note that this transformer is not lazy and instead <em>eagerly evaluates</em> the data in asynchronous threads. To avoid recalculation of the entire underlying range whenever e.g., std::distance is called, this transformer intentionally changes the stream type to InputRange. The downside is that no further transformations can be appended (except for <a class="el" href="group___stream.html">Stream modifiers and data types.</a> stream::rebatch) and everything has to be prepared before the application of this transformer.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};</div><div class="line"><span class="keyword">auto</span> buffered_rng = data</div><div class="line">  | <a class="code" href="group___stream.html#gabdf7aa0a0a0d369f631e4d99f8902397">ranges::view::transform</a>([](<span class="keywordtype">int</span> v) { <span class="keywordflow">return</span> v + 1; })</div><div class="line">  | <a class="code" href="group___stream.html#gad2959b9ed9c589f9f493ecd2198abdf2">buffer</a>(2);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00181">181</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="gad05dc07f4ec4ef94a891ab95c5939dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad05dc07f4ec4ef94a891ab95c5939dc0">&#9670;&nbsp;</a></span>create</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ranges::view::view&lt;detail::create_fn&lt;Columns...&gt; &gt; hipipe::stream::create {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a data range to a HiPipe stream. </p>
<p>The value type of the input range is supposed to be either the type represented by the column to be created, or a tuple of such types if there are more columns to be created.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(age, <span class="keywordtype">int</span>)</div><div class="line"></div><div class="line"><span class="comment">// rng is a stream where each batch is a single element from 0..9</span></div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10) | create&lt;id&gt;();</div><div class="line"></div><div class="line"><span class="comment">// batched_rng is a stream with a single batch with numbers 0..9</span></div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10) | create&lt;id&gt;(50);</div><div class="line"></div><div class="line"><span class="comment">// also multiple columns can be created at once</span></div><div class="line"><span class="keyword">auto</span> rng = view::zip(view::iota(0, 10), view::iota(30, 50)) | create&lt;id, age&gt;();</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch_size</td><td>The requested batch size of the new stream. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="create_8hpp_source.html#l00111">111</a> of file <a class="el" href="create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="ga7322d5bcc2c24a6b3537940c286ba8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7322d5bcc2c24a6b3537940c286ba8f5">&#9670;&nbsp;</a></span>drop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ranges::view::view&lt;detail::drop_fn&lt;Columns...&gt; &gt; hipipe::stream::drop {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops columns from a stream. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data | create&lt;id, value&gt;() | drop&lt;id&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="drop_8hpp_source.html#l00067">67</a> of file <a class="el" href="drop_8hpp_source.html">drop.hpp</a>.</p>

</div>
</div>
<a id="ga2e0cef72ffbd8f645a067ddb4b98149b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0cef72ffbd8f645a067ddb4b98149b">&#9670;&nbsp;</a></span>keep</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ranges::view::view&lt;detail::keep_fn&lt;Columns...&gt; &gt; hipipe::stream::keep {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep the specified columns in the stream, drop everything else. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(<span class="keywordtype">id</span>, <span class="keywordtype">int</span>)</div><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">double</span>)</div><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data = {{3, 5.}, {1, 2.}};</div><div class="line"><span class="keyword">auto</span> rng = data | create&lt;id, value&gt;() | keep&lt;value&gt;;  <span class="comment">// now it has only the value column</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="keep_8hpp_source.html#l00067">67</a> of file <a class="el" href="keep_8hpp_source.html">keep.hpp</a>.</p>

</div>
</div>
<a id="gaa60d28c3d0e6fcaa19ee75b412f56243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa60d28c3d0e6fcaa19ee75b412f56243">&#9670;&nbsp;</a></span>rebatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ranges::view::view&lt;rebatch_fn&gt; hipipe::stream::rebatch {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate the stream and yield batches of a different size. </p>
<p>The batch size of the accumulated columns is allowed to differ between batches. To make one large batch of all the data, use std::numeric_limits&lt;std::size_t&gt;::max().</p>
<p>Note that this stream transformer is not lazy and instead <em>eagerly evaluates</em> the batches computed by the previous stream pipeline and reorganizes the evaluated data to batches of a different size. To avoid recalculation of the entire stream whenever e.g., std::distance is called, this transformer intentionally changes the stream type to InputRange. The downside is that no further transformations or buffering can be appended and everything has to be prepared before the application of this transformer.</p>
<div class="fragment"><div class="line"><a class="code" href="group___stream.html#ga762e4b9643b235eec42b86533e3302da">HIPIPE_DEFINE_COLUMN</a>(value, <span class="keywordtype">int</span>)</div><div class="line"><span class="keyword">auto</span> rng = view::iota(0, 10)</div><div class="line">  | create&lt;value&gt;(2)  <span class="comment">// batches the data by two examples</span></div><div class="line">  | <a class="code" href="group___stream.html#gaa60d28c3d0e6fcaa19ee75b412f56243">rebatch</a>(3);       <span class="comment">// changes the batch size to three examples</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="rebatch_8hpp_source.html#l00168">168</a> of file <a class="el" href="rebatch_8hpp_source.html">rebatch.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
